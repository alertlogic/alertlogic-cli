# -*- coding: utf-8 -*-
"""
    alertlogic.dynapi
    ~~~~~~~~~~~~~~
    Implements dynamic apis based on metaprogramming, apidoc json data and the requests library
"""

import requests
import json
import logging
import os.path
import urllib, urlparse

API_DATA_DIR = os.path.abspath(os.path.dirname(__file__)+"/api_data")

API_SERVICES = ["sources", "scan_scheduler", "launcher"]

log = logging.getLogger()

class InvalidEndpointDefinition(Exception): pass
class InvalidEndpointCall(Exception): pass

class Services():
    """Creates and register one Service for each apidoc json file found in API_SERVICES
    these json files are published along the content of the html api documentation generated by apidoc
    more info: http://apidocjs.com
    """
    def __init__(self):
        for service_name in API_SERVICES:
            filename = API_DATA_DIR+"/"+service_name+".json"
            service = self.parse_apidoc_file(filename)
            self.__dict__[service_name] = service

    def parse_apidoc_file(self, filename):
        """generates a Service() object by parsing an apidoc json file
        :param filename: path to apidoc json file
        """
        with open(filename) as file:
            api_data = json.load(file)
            return self.parse_apidoc(api_data)

    def parse_apidoc(self, api_data):
        """Parses apidoc data (dict) into a Service() object
        :param filename: python dict representing an apidoc json file
        """
        service = Service()
        for api_data_endpoint in api_data:
            try:
                name = api_data_endpoint["name"]
                operation = api_data_endpoint["type"]
                url = api_data_endpoint["url"]
                service.add_endpoint(name, operation, url)
            except (KeyError, InvalidEndpointDefinition) as e:
                log.debug("unable to parse apidoc endpoint: {}".format(e))
                pass
        return service

    def set_session(self, session):
        """this function makes it easier to call set_session on all the underlying services
        :param session: an alertlogic.auth.Session object
        """
        for service_name in API_SERVICES:
            service = self.__dict__[service_name]
            service.set_session(session)

class Service():
    """Stores a set of Endpoint()s and allows to call them dynamically as functions
    by using metaprogramming
    """
    def __init__(self):
        self._endpoints = {}
        self._session = None

    def add_endpoint(self, name, operation, url):
        """Creates and stores an Endpoint() see Endpoint class for more info
        """
        endpoint = Endpoint(name, operation, url)
        self._endpoints[endpoint.name] = endpoint

    def set_session(self, session):
        """ changes current session, sessions are used to authenticate api calls
        and to override account id when a call doesn't provide it
        :param session: an authenticated alertlogic.auth.Session object
        """
        self._session = session

    def __getattr__(self, name):
        """returns an unbound function *handler* capable of calling a Endpoint()
        in python this function is called everytime an object's property is not found
        this is what allows us to dynamically add functions to an existing object
        """
        if name in self._endpoints:
            def handler(*args, **kwargs):
                # json argument are passed separately
                json = kwargs.pop("json", None)
                # if account_id is not an argument then use the one provided by session
                if "account_id" not in kwargs:
                    kwargs["account_id"] = self._session.account_id
                return self._endpoints[name].call(self._session, kwargs, json=json)
            return handler
        else:
            # you've tried to call an undefined endpoint
            raise InvalidEndpointCall("endpoint not found: {}".format(name))

class Endpoint():
    """Represents 1 service endpoint, requirements:
    * name
    * an operation ("POST", "GET", etc)
    * url, the format should be the one used in apidoc, this means required url arguments
    start with ":" e.g:
    /scheduler/v1/:account_id/:environment_id/scan?asset=:asset_key
    to call the above endpoint you'll need to provide account_id, environment_id and asset_key
    """
    def __init__(self, name, operation, url):
        """
        :param name: endpoint's name
        :param operation: either "get", "post", "delete", "put" or "head"
        :param url: url using apidoc format (parts that start with ":" are parameters)
        """
        self.name = name.lower()
        self.url = url
        self.operation = operation.upper()
        # verifies that the given operation is correct
        if self.operation not in ["GET", "POST", "DELETE", "PUT", "HEAD"]:
            raise InvalidEndpointDefinition("invalid operation: {}".format(self.operation))

    def parse_url(self, url_args):
        """Parses an endpoint's url by replacing the parts that start with ":" with the values of *url_args*
        e.g:
            endpoint.url = "/scheduler/v1/:account_id/:environment_id/scan?asset=:asset_key"
            endpoint.parse_url({"account_id": "2",
                                "environment_id": "BA395435-551B-4250-B52E-71FCCFF73124"
                                "asset_key": "/aws/us-east-1/host/i-023c7629"})
            "/scheduler/v1/12345678/BA395435-551B-4250-B52E-71FCCFF73124/scan?asset=/aws/us-east-1/host/i-023c7629"
        :param url_args: dict with values to replace url parameters
        """
        parsed = list(urlparse.urlparse(self.url.lower()))
        parsed[2] = substitute_path_args(parsed[2], url_args)
        parsed[4] = substitute_query_args(parsed[4], url_args)
        return urlparse.urlunparse(parsed)

    def call(self, session, url_args, json=None):
        """parses the url (see parse_url()), and makes an http call, uses session as requests auth plugin
        :param session: a session object for authentication
        :param url_args: dict with values to replace url parameters, see parse_args() for more info
        :param json: this will be passed adhoc to requests
        """
        parsed_url = session.api_endpoint + self.parse_url(url_args)
        log.debug("calling requests: operation={} url={} json={}".format(self.operation, parsed_url, json))
        return requests.request(self.operation, parsed_url, json=json, auth=session)

def substitute_path_args(path, args):
    parts = [part for part in path.lower().split("/") if len(part) > 0]
    substituted = ""
    for part in parts:
        if part.startswith(":"):
            required_arg = part[1:] # removes ":" at the beginning of the string
            if required_arg in args:
                substituted += "/" + args[required_arg]
            else:
                raise InvalidEndpointCall("missing required url argument {}".format(required_arg))
        else:
            substituted += "/" + part
    return substituted

def substitute_query_args(query, args):
    parsed = urlparse.parse_qs(query)
    for key in parsed:
        value = parsed[key][0]
        if value.startswith(":"):
            required_arg = value[1:] # removes ":" at the beginning of the string
            if required_arg in args:
                parsed[key] = args[required_arg]
            else:
                raise InvalidEndpointCall("missing required url argument {}".format(required_arg))
    substituted = urllib.urlencode(parsed)
    substituted = urllib.unquote_plus(substituted)
    return substituted
